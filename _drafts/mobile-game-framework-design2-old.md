##### 游戏数据开发
1) 静态数据(配表数据)
在你把数值把数据配置出来后，是不是需要为每一份配置表写一次解析呢？静态数据的设计主要考虑两个方面，一个是设计的人，一般就是策划，另一方是使用的人，一般就是程序。对策划来说，excel是最理想的工具，对程序来说，csv是性能比较好的容易解析的格式。当然，也有excel导出xml或者json的(个人比较讨厌xml)。
常见的方案是，策划每增加一份配表，程序员就需要为这张表写一份专门的解析文件，并且为表数据定义数据结构，比如：

	struct HeroItem{
		int hp;
		int atk;
	};
	typedef std::vector<HeroItem> HeroDB;
	void parserHeroDB(const char* buf, HeroDB& db);

我说一下我的方案，给策划约定一种方式，程序可以不写解析，只管用就可以了。比如：

	print(DataPort.HeroDB[heroId][lv].hp)
	
这个例子，我们查询配表中的某个heroId的英雄在lv等级下的血量

实现方式如下：
关键是设计一张描述其他表的表，告诉解析器怎么加载这些表。具体来讲，解析器需要知道：

1.每列都是什么类型的数据，我的设计是分开4种：数值、字符串、数值数组、字符串数组。

2.怎么建立索引，每一列数据属于哪个字段，其中哪个字段为key，而且考虑支持三维表，即多一个subkey，一般就够用了，也应该约束最多三维，太多那几乎就是设计上存在问题。

设计data_list.csv，这张表描述hero.csv怎么解析，例子如下：

	data_list.csv
	id      file_name       main_key      sub_key        descript
	HeroDB  hero.csv        id            level          0;0;0;0;

	hero.csv
	id      level           hp            atk
	1       1               10            13
	1       2               11            14
	1       3               12            15
	2       1               20            5
	2       2               22            5
	2       3               24            5

其中data_list.csv中的descript中0;0;0;0表示的数值;数值;数值;数值刚好对应hero.csv中一行的解析，在这里我用0表示数值解析。
有了上面这些约定，我们就很容易写一个解析器完成数据的解析，解析后赋值在HeroDB中，从而我们可以直接从里面取数据。

这样做的好处很明显，数据表是经常变动的，如果用前一种方法，每一次变动我们都要改数据结构->改解析代码->改相应的逻辑，那样太繁琐的。不如我们把它的变化抽出来，专门给导致变化的人(策划)自己折腾。这样就不用浪费程序员宝贵的时间。