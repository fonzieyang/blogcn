---

layout:     post
title:      "我的编程感悟"
subtitle:   "程序设计就是语言设计 ----松本行弘"
categories: 心得
tags: [心得, tag]
header-img: "img/drop-of-water-597109_1920.jpg"

---



## 零、 编程的核心困难的是什么？

什么是编程？

程序设计是给出解决特定问题程序的过程，是软件构造活动中的重要组成部分。程序设计往往以某种程序设计语言为工具，给出这种语言下的程序。程序设计过程应当包括分析、设计、编码、测试、排错等不同阶段。专业的程序设计人员常被称为程序员。 某种意义上，程序设计的出现甚至早于电子计算机的出现。英国著名诗人拜伦的女儿爱达·勒芙蕾丝曾设计了巴贝奇分析机上计算伯努利数的一个程序。她甚至还创建了循环和子程序的概念。由于她在程序设计上的开创性工作，爱达·勒芙蕾丝被称为世界上第一位程序员。 任何设计活动都是在各种约束条件和相互矛盾的需求之间寻求一种平衡，程序设计也不例外。 

复杂。编程不仅仅是解题，得到的不仅仅是答案，还要是一个可维护的答案。可维护意味着，要求答案足够简洁，有足够的可读性，否则维护的人无法理解。随着问题的复杂度提升，答案的复杂度也会随之提升。编程是很复杂的工作，以至于作为一门工科显得很不严谨，只要运作不出问题就当做没问题。因此化繁为简最为重要，因此编程最核心的技巧是抽象。

抽象是简化问题的方法。什么是抽象？抽象就是对问题的合理拆分。就像流水线一样，可以把工序拆成n个步骤。使得每个步骤足够简单机械。为什么要抽象？因为太复杂的东西，人类理解不了。拆分问题需要从人能够理解的角度出发。所以编程没什么好恐惧的，只要符合逻辑，都能写出来，只要懂得分解问题即可。还是以流水线为例，仅仅是问题分解是不够的，还要对工序本身有深入的理解，知道怎么拆才能比较简洁，能够对抗变化，才是好的拆分。所以有人认为编程最难的事情就是命名。

一方面体现在代码是写给人看的，要符合语义，最好能像自然语言一样；另一方面，***人在一个层次上能同时处理概念的数量通常只有7个***，抽象恰恰就是在为这种符合人性的需求，对问题规模进行切割。抽象还有很多好处，比如能够隔离变化，能够控制依赖方向，能够留下扩展空间。

直白地写代码，是很难对抗变化的，没有给自己留下变化的余地，这是很不负责的。见过不少项目都会对每个系统调用都包装一层函数，哪怕是没有任何功能都可以。这样以后希望可以统计内存分配，那么只要在包装函数里面做就可以。

所有技巧是为了某个目的服务的。解决一个问题，我们会有很多概念、逻辑在里面，而这些"术语"则构成了一门语言来表达我们的想法。因此，我们不能盲目的抽象，而是围绕一个中心思想，系统地提炼出这些抽象来解决问题。比如Unix就会有"进程"这样的抽象来解决多任务的问题。渲染引擎会有"渲染管线"这样的抽象来解决复杂的渲染问题，虽然图形渲染几十年来的变化翻天覆地，但是硬件上的渲染管线基本上还是那一套。

所以技术只是手段，关键是我们如何看待问题才是重点。在进行合理的抽象之后，我们能够得到简洁优雅、可读性高、相对高效的代码，意料之内的变化只需要改变一个地方，意料之外的变化能够从容应对。也因为没有重复、可读性高，所以代码覆盖也高，最终bug也会减少。最终我们得到一个KISS的结果。

---

## 一、 动手之前，请先厘清问题

之前说了，关键还是取决于对问题的理解程度上。如果你之前从头到尾做过一款有一定规模的项目，那么下一次再写就会很漂亮，***不是技术牛了，而是对问题理解深了***。就像单词背多了，英语句子总能看得懂。比如游戏框架，需要你对写过大量游戏进行共性提炼，很容易发现数据与显示分离的好处，并且设计出合理的框架。

比如游戏和Web服务器就非常不一样，一个经常需要带状态、长连接、经常广播、实时性强，另外一个经常是无状态、短连接、很少广播、实时性弱。这样的话，设计起来就完全不同。对业务有了深入的理解，才能为客观事实设计出合理的代码。

很多缺乏经验的程序员，一上手一个项目，就会立刻钻进源代码里面，这是很没必要的。其实只要理解了问题，以及理解设计思路之后，代码如何编写都是比较简单的事情。

## 二、 方向比努力更重要

***杀鸡用牛刀是没问题的，但是反过来不成立***。提前构建好，胜于等待需求冲击。有些东西易放难收，一开始就把抽象做起来，养成工整的代码习惯，发现不合理的地方立即重构。

对于全局性的接口，要一开始就把接口设计好。如果项目中扩散着各种因为这个接口导致的脏代码，想在后面再收，那就很痛苦了。很多东西确实需要提前想清楚。比如热更新、性能指标、部署等等。


## 三、聪明地写代码，拒绝无脑臃肿

如同几何一样，我们可以定义最基础的公理，推论出一系列的有用的推理。类似地，编程也可以做到这样的程度，通过元编程，我们可以把真理(很多时候是常量)只定义在一个地方，然后通过元编程，传递到需要的角落。

很多时候，重复是不自觉的。比如说，很多项目都会孜孜不倦地定义配置数据，然后又手写parser。但其实如果有约定好的规范，那么这个过程完全可以自动化。比如说一些资源需要配置起来，但是其实是有内在关系，可以通过约定指定目录来加载的。类似的事情还是有很多，事实上，我们只要约定好，就可以少了很多中间的无谓步骤。

还有就是要对代码进行思考，而不是完成功能就算了。经常能看到C程序员写出这样的代码：

{% highlight C++ %}
if (a == true)
  return true;
else
  return false;
{% endhighlight %}

无论如何，稍微经过脑子，提炼一下，其实就只是一行代码

{% highlight C++ %}
return a;
{% endhighlight %}

还有经常写出一堆switch case的，完全可以记录在map里面，直接查出来处理的话，代码就不会那么臃肿了。

当然，类似的细节还有很多很多...魔鬼在细节中，不可能读了一篇文章就马上成为高手，必须经过大量练习，才能下意识地写出精炼的代码。

---

## 四、 面向对象是顺应历史潮流的


从历史的角度来看，面向对象是好东西。在过去goto语句横行的年代，曾经发生过代码的结构化编程：取消goto语句，只能使用顺序、循环、分支替代，从而让代码统一易读。而面向对象则是对数据的结构化编程，让数据更加抽象，***让大家操作数据的时候不用关心数据有什么字段***，而且对象的思路也能帮助我们进行抽象，提升代码抽象层次，而且还让我们更容易进行思考。

但我们要小心类似C++这种面向对象，其中继承承担了接口以及复用两个责任，很容易用错。容易为了一点点的性能而走火入魔。

---

## 五、 分层是最好的架构

分层的优点在于，***依赖方向得到最好的控制***，而且代码复用高、耦合低。每个层次有自己的核心问题，比如引擎这一层就是做一些与业务无关的基础输入输出，比如渲染器、物理引擎、输入等等。比如框架层就是为业务支撑的，着眼于开发效率。
